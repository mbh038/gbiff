---
title: "GBIF Occurrences"
author: "Michael Hunt"
date: "12/10/2025"
format: html
editor: visual
execute: 
  warning: false
  message: false
---

tldr: If you have already entered your GBIF user name, password and email into this script, have set up your .Renviron file, then the quickest way to get what you want each time is to enter the scientific name here of the taxon you are interested in, then press Run/Run All. A few minutes later, when the GBIF download has completed, you will find in the output subfolder a csv file, shapefile and Geopackage for ocurrences of that taxon, as recorded on GBIF.

```{r}
scientific_name <- "Panthera uncia" # Don't forget to run this chunk. Press the green arrow at the top right of the chunk.
```


If you haven't, go through the rest of the script and implement each chunk, one chunk at a time. 

You can use this script to search for occurrences of a taxon on [GBIF](https://www.gbif.org) and then download the data directly into R for subsequent analysis here in this script. You can also save the data as a csv file for later analysis or as a Shapefile or GeoPackage for inclusion as a vector point layer in a GIS application. Finally, the script generates a basic static map and a basic dynamic map

## Preliminary.

You need to have registered with GBIF manually ie not using your Google, Apple , ORCID or similar ID. For this script to work, you need to know your GBIF username and password, and the email address you use to communicate with GBIF. All of these can be found on your GBIF profile.

To avoid having to have these personal details hard coded into this script, you can run this [little file](here(gbif_setup.qmd)). This will ask you to enter them into a hidden .Renviron file (which you then save and close, never to open it again) from where they can be retrieved by GBIF. All you need to do then is restart R and you should be then able o get occurrence data from GBIF without having to have them in this script.


### Load packages

```{r}
library(rgbif)
library(tidyverse)
library(here)
library(sf) # for vector spatial data
library(leaflet) # for dynamic mapping
library(tmap) # for static mapping
```

## Step One

What is the scientific name of the species for which you want to find occurrences?

The script thinks you are looking for

```{r}
scientific_name
```


If that is not right, go back up to the top and enter what you want.


We give this to GBIF and let it look through its records to find the unique species key for this species. If it cannot find it, check if you have spelled the scientific name correctly.

```{r}
species_key <-name_backbone(scientific_name) |>
  select(speciesKey) |>
  pull()
```

Alternatively, you can find the species key on GBIF's site in various ways, for example by doing an occurrence search then looking at the final digits of the url of the species page you end up on. I did a search on puffins *Fratercula arctica* and ended up on [this page](https://www.gbif.org/species/2481353) for them. The url of that page is `https://www.gbif.org/species/2481353` and the species ID in GBIF for puffins is 2481353.

## Step Two: Search on GBIF for occurrences of the selected taxon

Be as selective as you can in order to avoid getting huge downloads (there are over 3 billion records on GBIF in total!). You can select by date, area, country - many things, using one of several `pred()` functions. For help on the available keys and `pred()` functions, type `?pred` in the console pane.

```{r, cache = TRUE}
gbif_download <- occ_download(pred("speciesKey",species_key),
                              pred_default(),
                              pred_gte("year",1900), # try also gt, lt, lte etc
                              
# use a two letter country ID or combination of IDs
                              pred_in("country",c("CN", "IN", "KZ", "MN", "NP", "PK", "RU", "TJ", "UZ")),

# you can omit the following lines, as I have, if you have set up your .Renviron file.
# If you have not done that, uncomment the following three lines and add the details required.

                              # user="your GBIF username",
                              # pwd = "your GBIF password",
                              # email = "the email you have used on your GBIF profile",
                              format = "SIMPLE_CSV")
```

This chunk will tell you when the download is done. That might take a few minutes, or even longer for large downloads. Most downloads are complete within 15 minutes.

```{r, cache = TRUE}
 occ_download_wait(gbif_download)
```

When the download is ready, read the data into a data frame and write it out into a `.csv` file. You can upload this into a spreadsheet if you like, using the guidance given below.

```{r}
# create folder <scientific name> in /output
new_dir_path<-here("output",scientific_name)
dir.create(new_dir_path)

download_df <- occ_download_get(gbif_download, overwrite = TRUE) |>
    occ_download_import()

# remove the downloaded zip file
 download_key <- occ_download_meta(gbif_download)$key
 file.remove(here(paste0(download_key,".zip")))
 
# save df as csv file in output/<scientific name>
filepath <- here("output",scientific_name, str_c(scientific_name,".csv"))
write_csv(download_df,filepath)
```

The data are now in your R session as a data frame called `download_df`. Scroll across the columns and see what you have got.

## Convert data frame to spatial object in WGS84

We can use functions from the `sf` package to convert the data frame we have just created into a spatial object that we can then write out as a Geopackage or a shapefile for inclusion in a GIS as a vector layer.

We need to tell it which columns are the longitude and latitude. The default in GBIF downloads is that they are called `decimalLongitude` and `decimalLatitude`, so we will use those names. Amend the code below if the names are any different in your download, for some reason.

In this code chunk, we set the CRS of the spatial data object `download_sf` to be 4326, ie WGS84, which is a geographic CRS, with positions and distance measured in degrees. Further down the line, this may not be what you want...

```{r}
download_sf <- download_df |>
  st_as_sf(coords = c("decimalLongitude", "decimalLatitude"), crs = 4326) |>
  st_cast("POINT")
download_sf
```

### Save as a geopackage or shapefile

The spatial object in R that we have created from the GBIF download can be used directly in R for GIS mapping, but can also be saved to disc as a shapefile or GeoPackage (my preferred option) for subsequent plotting as a vector layer in a dedicated GIS application such as QGIS.

#### Save as a Shapefile

For this format we create a sub-folder within the output folder, named after the scientific name of the species, and put all the component files of the shapefile we create in there, collected together within another subfolder called <scientific_name_shp>.

```{r, warning = FALSE, message = FALSE}

new_dir_path<-here("output",scientific_name)
if(!dir.exists(new_dir_path)){
  dir.create(new_dir_path)
}

folder_path <- paste0(getwd(),"/output/",scientific_name,"/",paste0(scientific_name,"_shp"))
ifelse(!dir.exists(folder_path),
       dir.create(folder_path), # create a new sub folder if one didn't exist already
       "Folder exists already") # don't do this if it does.
       
filepath<-here("output",scientific_name,paste0(scientific_name,"_shp"),paste0(scientific_name,".shp")) 
st_write(download_sf, filepath, append = FALSE)
```

#### Save as a Geopackage

We save this into the subfolder output/<scientific name>

```{r}
filepath<-here("output",scientific_name, paste0(scientific_name,".gpkg"))
st_write(download_sf, filepath, append = FALSE)
```

## Map the occurrence data

The mapping code presented here just scratches the surface of what you can do - pretty much all of GIS can be done in R.

### Static map using `tmap`

```{r}
# make some bbox magic
bbox_new <- st_bbox(download_sf) # current bounding box
xrange <- bbox_new$xmax - bbox_new$xmin # range of x values
yrange <- bbox_new$ymax - bbox_new$ymin # range of y values
# bbox_new[3] <- bbox_new[3] + (0.25 * xrange) # xmax - right
# bbox_new[4] <- bbox_new[4] + (0.2 * yrange) # ymax - top

bbox_new <- bbox_new |>  # take the bounding box ...
  st_as_sfc() # ... and make it a sf polygon

# tmap with 2 layers

	tm_shape(download_sf, bbox = bbox_new)+
	  tm_basemap(providers$Esri.WorldGrayCanvas) +
  tm_dots(col = "blue", size = 0.2, alpha = 0.8) +
  tm_compass(position = c("left", "top"))+
  tm_scalebar(position = c("right", "top"))+ 
  tm_borders(fill_alpha=1, lwd = .1, col = "red")+
  tm_legend(legend.format = list(text.separator= "a")) +
  tm_layout(legend.position = c("right", "top"),
            frame = FALSE) +
  tm_legend(show = FALSE)
```

### Dynamic map using `leaflet`

```{r}
m <- leaflet(download_df) |>
  # addTiles() |>
  addProviderTiles(providers$Esri.WorldGrayCanvas) |>
  addCircleMarkers(~decimalLongitude, ~decimalLatitude, label = ~basisOfRecord)
m
```
